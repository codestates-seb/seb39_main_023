# CODESTATES MAIN PROJECT TEAM 23 백엔드

작성자 : 장원용

## 1. 메인 프로젝트 일정 체크   

1. 개발 기간 ~10/7   
2. 테스팅, 버그 픽스 ~10/14   
3. 전체 테스트 ~10/17   
4. 배포 ~10/18   



위 일정에서 일주일씩 당겨질 수도 있음





## 2. 백엔드 서비스 아키텍처 참고 이미지


![back_008](https://user-images.githubusercontent.com/80381715/189267330-7c597498-5670-498f-8579-81bca05b26f5.jpg)

## 3. 백엔드 개발 일정

1 주차 ~09/17   
  - ToDo :  
  
    1. 프로젝트 주제 선정
  
    2. 사용할 리소스 계획
  
    3. DB 스키마 작성 
    
    4. 리소스 응답용 REST 메소드 작성
    
    5. side 기능 확인 및 정의
    
  
2 주차 ~09/24  
  ToDo :
  
3 주차 ~10/01  
  ToDo :
  
4 주차 ~10/08   
  ToDo :


   


5 주차 ~10/15



## 4. 의문사항


1. BFF 적용시 서비스의 분리(Bounded Context)가 중요한데 이때 엔티티 연관관계를 어떻게 처리 해야하는가?

    * 내 생각 : 엔티티 연관관계를 분리 시키고(실질적으로는 DB를 분리 - 하지만 프로젝트 기간을 고려 하나의 DB에 테이블 분리로 설계?), 서비스간에 통신을 사용하여 가능한 서비스의 분리를 유지하는게 맞는것 같다.
    
    
    * 검색 결과(키워드): 데이터 복제, 서비스의 느슨한 결합, JOIN 테이블 사용 - 이 기종 DB의 JOIN 구현 : Presto, Kafka 이용하여 메세지 구독을 이용 응답 조합 서비스를 따로 생성
    

2. 그럼 아토믹하지 않은 상황이 발생할 수 있다.

    * 내 생각 : 분산 트랜잭션을 여기에 적용해야 하지 않을까?
    
    * 검색 결과 : 2Phase Commit - 결합도 상승, 과도한 락 설정으로 성능 감소 이슈, 단일 DB 사용 or Saga Pattern을 적용

3. 프론트 서버를 믿고 리소스를 한번에 보내는 방식으로 구현 할 것인가, 백엔드에서 임의로 응답을 컨트롤하는 방식을 취할 것인가?

4. REST API를 적용하면서 발생할 conflict - end point의 부재, type 불일치 문제, 네트워크 에러, 복합키와 같은 리소스 접근 표현이 애매한 상황
    * 내 생각 : 404 핸들링 추가하기?, 모든 서비스에서 일단 응답 데이터를 랩핑하는 과정을 넣어야 하는가 아니면 무조건 설계를 잘 하기?, 트랜잭션을 이용하기?, Document based NoSQL Mongo DB 사용하여 한번에 리소스 핸들링 가능
    
5. client 사이드에서 제일 먼저 마주하는 Contents Aggregator 서버에 다중 사용자의 요청이 들어오면 어떻게 처리가 되는 것일까?
    * 내 생각 : 스프링 부트를 실행 메세지에서 확인 가능한 내장 톰캣, 스레드 풀이 아마 자동(기본 정책이 있을것 같다)으로 처리하고 있는 것 같다
    
 ## 5. 적용을 시도 해볼만한 기술
  - h2+spring data jpa 대신에 redis(sub, cache)+spring data redis+ehcache + mysql(main)
  - spring security 필터체인 대신 interceptor
  - 도커 컴포즈(실무에서는 쿠버네티스를 이용한다고 한다.)를 이용, 서비스 분리, BranchByAbstraction 개념 적용해보기
  - 다중 접속 상황을 가정하여 Contents Aggregator의 비즈니스 로직에 비동기, 논블로킹 개념 적용

## 6. 컨벤션
- 네이밍
  - 대문자 카멜 케이스로 클래스명
  - 소문자 카멜 케이스로 필드(클래스랑 구별이 되도록), 함수, 파라미터, 내부 지역변수 

- 개행
  - 임포트 아래 두줄
  - 메소드 시그니쳐 아래 한줄
  - 클래스 이름 아래 한줄
  - 필드 선언 부분은 한번에, 아래에 로직 부분 들어가기 전에 한줄
  - 필드랑 로직이 합쳐져 있으면 한개의 블럭으로 만들고 한줄 return 부분 분리
  - return 아래에는 개행 없이, 단독 사용시 가능한 위아래 개행 없이 작성
  - 필드 블록 위아래 개행
  - 가능하면 연관있는 것들끼리(같은 지역변수 공유, 반복문 등) 하나의 블록으로 구성, 위아래 개행 넣기

- 주석 컨벤션
  - 주석은 클래스 위 혹은 메소드 위에 작성
  - 주석 블록을 위아래 개행으로 분리
  - description : 기능, 구조, 작성 이유 설명
  - Todo - 리팩토링 할 사항
  - Study - 공부 해봐야할 사항
  - Advanced - 고려해볼만한 심화 기능
  - Trouble - 코드 기능 구현 중 발생한 문제
  - Solution - 어떻게 해결하였는 지
  - ETC - 코드 작성하다가 느낀점, 기타 사항

- 클래스 어노테이션
  - 빈설정 어노테이션이 제일 위
  - 경로 맵핑
  - 생성자관련 어노테이션
  - 게터/세터/데이터
  - 스웨거 설정
  - 필드위에 스웨거 설정
  - 개행 없이 바로 붙여서

- 메소드 파라미터 어노테이션
  - 스웨거 설정 - 한줄로, 설명은 간단히!
  - 맵핑
  - 개행 없이 바로 붙여서

- 파라미터 어노테이션
  - 파라미터 유형
  - 스웨거 설정(dto의 경우 클래스명을 사용, Integer 와 같은 경우에는 파라미터 변수 이름을 사용)

- 커밋 말머리
  - feat : 새로운 기능 추가
  - fix : 버그 수정
  - docs : 문서 관련
  - refactor : 코드 리팩토링(고려요소)
  - test : 테스트 관련 코드
